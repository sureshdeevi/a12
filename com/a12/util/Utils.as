/* $Id$ */package com.a12.util{	import flash.display.*;	import flash.geom.ColorTransform;	import flash.text.*;		public class Utils	{			/*		Function: createmc			Creates an empty MovieClip and applies an object of properties			Usage1 - Utils.createmc(mc, name, depth, objProps);		Usage2 - somevariable = Utils.createmc(mc, name, depth, objProps);		Usage3 - somemc[somevariable] = Utils.createmc(somemc, somevariable, depth, objProps);			Parameters:				mc - parent MovieClip			name - string of new MovieClip			depth - depth			objProps - object of properties to be applied				Returns: 					MovieClip reference				*/			public static function createmc(mc:Object, name:String, objProps:Object = null):MovieClip		{			var sp = new MovieClip();			sp.name = name;						var tObj = {mouseEnabled:false};						for(var i in tObj){				sp[i] = tObj[i];			}									for(var j in objProps){				sp[j] = objProps[j];			}					mc.addChild(sp);			return sp;		}				public static function $(c1,c2:String):DisplayObject		{			return DisplayObject(c1.getChildByName(c2));		}				/*		Function: changeProps		Basic animation function, can handle any number of properties but only applies basic ease out		Parameters:			mc - movieclip			objProps - object of properties and their target values			easing - a number controlling the ease out rate (4) is common		*/		/*		public static function changeProps(mc:MovieClip, objProps:Object, easing:Number) : void		{			// need to subcontract easing formulas			// need to change to time based rather than frame based			mc.onEnterFrame = function() {				var done = true;				for (var prop in objProps) {					this[prop] = (this[prop] - ((this[prop] - objProps[prop]) / easing));					if ((Math.abs(this[prop] - objProps[prop]) > 1)) { // ***this test needs to be improved						done = false;					}				}				if (done == true) {					for (var prop in objProps) {						this[prop] = objProps[prop];					}									delete this.onEnterFrame;				}			}		}		*/		/*		Function: changeColor		Changes color of movieclip to hex value		Parameters:			mc - movieclip			rgb - hex value of new color		Returns: 			color		*/				public static function changeColor(mc:MovieClip, rgb:Number):void		{			var colorTransform:ColorTransform = mc.transform.colorTransform;			colorTransform.color = rgb;			mc.transform.colorTransform = colorTransform;					}				/*			Function: drawRect			Basic rectangle drawing, with fill and stroke			Parameters:				mc - MovieClip			w - width			h - height			rgb - fill color			alpha - fill alpha			lineStyle - array				*/		public static function drawRect(mc:MovieClip, w:Number, h:Number, rgb:Number, alpha:Number = 100, lineStyle:Array = null, x:Number = 0, y:Number = 0):void		{					mc.graphics.moveTo(x, y);			mc.graphics.beginFill(rgb, alpha);			if(lineStyle != null){				mc.graphics.lineStyle(lineStyle[0], lineStyle[1], lineStyle[2]);			}			mc.graphics.drawRect(x,y,w,h);			mc.graphics.endFill();				}				/*			Function: drawCircle			Basic rectangle drawing, with fill and stroke			Parameters:				mc - MovieClip						rgb - fill color			alpha - fill alpha			radius - 			lineStyle - array				*/		public static function drawCircle(mc:MovieClip, rgb:Number, alpha:Number = 100, radius:Number = 10, lineStyle:Array = null, x:Number = 0, y:Number = 0):void		{					//mc.graphics.moveTo(x, y);			mc.graphics.beginFill(rgb, alpha);			if(lineStyle != null){				mc.graphics.lineStyle(lineStyle[0], lineStyle[1], lineStyle[2]);			}			mc.graphics.drawCircle(x,y,radius);			mc.graphics.endFill();				}				/*			Function: drawRoundRect			Basic rectangle drawing, with fill and stroke			Parameters:				mc - MovieClip			w - width			h - height			rgb - fill color			alpha - fill alpha			radius - 			lineStyle - array				*/		public static function drawRoundRect(mc:MovieClip, w:Number, h:Number, rgb:Number, alpha:Number = 100, radius:Number = 10, lineStyle:Array = null, x:Number = 0, y:Number = 0):void		{					mc.graphics.moveTo(x, y);			mc.graphics.beginFill(rgb, alpha);			if(lineStyle != null){				mc.graphics.lineStyle(lineStyle[0], lineStyle[1], lineStyle[2]);			}			mc.graphics.drawRoundRect(x,y,w,h,radius,radius);			mc.graphics.endFill();				}				public static function makeTextfield(mc:Object, display:String, format:TextFormat, props:Object = null):TextField		{			var tf = new TextField();									var tObj = {				name:'displayText',				mouseEnabled:false,				selectable:false,				width:20,				height:10,				embedFonts:true,				wordWrap:true,				autoSize:TextFieldAutoSize.LEFT												};						for(var i in tObj){				tf[i] = tObj[i];			}									for(var j in props){				tf[j] = props[j];			}									tf.text = display;			tf.htmlText = display;						if(tf.styleSheet == undefined){				tf.defaultTextFormat = format;				tf.setTextFormat(format);			}			mc.addChild(tf);			return tf;		}				/*		Function: convertSeconds		Creates an object with minutes and seconds properties from a number of seconds		Parameters:			time - number of seconds		Returns: 			object with minutes and seconds properties		*/		public static function convertSeconds(time:Number):Object		{			var tObj = {};			if((time / 60) > 1){				tObj.minutes = Math.floor(time/60);				tObj.seconds = time%60;						}else{				tObj.minutes = 0;				tObj.seconds = time;			}			return tObj;		}				/*		Function: padZero		Adds a 0 to a number less than 10 and returns as a string. If number is greater than 10 it returns that number as a string		Parameters:			num - number		Returns: 			string of the number		*/		public static function padZero(num:Number):String		{			if(num < 10){				return '0' + num;			}else{				return String(num);			}		}				public static function getScale(objWidth:Number,objHeight:Number,contWidth:Number,contHeight:Number,scaleMode:String='fit'):Object		{			//need to handle way to toggle on off Math functions (ceil,floor)						var scale = 100;			var scaleObj = {};						//scale from 0 to 100, proportionally based on available space			if(scaleMode == 'fit'){								switch(true){					case objWidth > contWidth:						scale = Math.ceil(100 *(contWidth)/objWidth);						if((scale/100) * objHeight > contHeight){							scale = Math.ceil(100 *(contHeight)/objHeight);						}					break;					case objHeight > contHeight:						scale = Math.ceil(100 *(contHeight)/objHeight);						if((scale/100) * objWidth > contWidth){							scale = Math.ceil(100 *(contWidth)/objWidth);						}					break;				}								scaleObj.x = scale;				scaleObj.y = scale;							}						//scale from 0 to n, non-proportionally			if(scaleMode == 'fill'){				scaleObj.x = '';				scaleObj.y = '';			}						//scale from 0 to n, proportionally			if(scaleMode == 'scale'){				switch(true){					case objWidth < contWidth:						scale = Math.ceil(100 *(contWidth)/objWidth);						if((scale/100) * objHeight > contHeight){							scale = Math.ceil(100 *(contHeight)/objHeight);						} 					break;					case objHeight < contHeight:						scale = Math.ceil(100 *(contHeight)/objHeight);						if((scale/100) * objWidth > contWidth){							scale = Math.ceil(100 *(contWidth)/objWidth);						}					break;				}								scaleObj.x = scale;				scaleObj.y = scale;			}						return scaleObj;		}			/* 			Function: getPositionByOffset			Finds location in array starting from index based on offset			Parameters:				ind - index			len - length of array			offset - distance (+/-)			Returns: 					number			*/			public static function getPositionByOffset(ind:Number,len:Number,offset:Number):Number		{			var t = ind+offset;					switch(true)			{				case (t < 0) && (offset<1):					t = (len)-Math.abs(t);				break;						case (t > (len-1)) && (offset>-1):					t = t-len;				break;					}					return t;		}			/* 			Function: toRadians			Converts degrees to radians			Parameters:				deg - degrees			Returns: 					radians			*/			public static function toRadians(deg:Number):Number		{			return deg * Math.PI/180;		}		}	}